# MathFoPLab2
## Отчёт по лабораторной работе №2<br>по дисциплине "Математические основы программирования"<br>студента группы ПА-18-2<br>Рябова Андрея Дмитриевича

Тема: __"Неформальное доказаельство правильности программ, которые содержат разветвления"__

### Постановка задачи

Написать программу в соответствии с индивидуальным вариантом задания,
составить спецификацию и доказать правильность программы в ручном режиме
согласно спецификации с помощью фиксации состояний программы
после выполнения каждой команды.   
В каждом из вариантов заданий программа получает на входе значения A, B, C, а также дополнительные данные согласно варианту.
 
 **Индивидуальный вариант (№15):**   
 Вычислить максимум подмножества элементов принадлежащих или не принадлежащих заданному
промежутку [L; R], в зависимости от того, их сумма больше их произведение.
 
 ### Описание решения:
 
 0. Определим, что существует **предусловие**, **код** и **постлусловие**:
 `{Q} S {R} `
 1. Составим **предусловие** для варианта задания:
 `Q: {m(A, B, C) ⋀ (l = L) ⋀ (r = R)}`
 2. Составим промежуточные состояния предикатов в коде:   
>if(A[0] >= l and A[0] <= r) {   
>		sum += A[0];   
>		mult *= A[0];   
>		if(max1<A[0]) {   
>			max1 = A[0];   
>		}   
>		b1 = 1;   
`m(A, B, C) ⋀ (l = L) ⋀ (r = R) ⋀ (Σi: i=i: (m[i] >= l) ⋀ (m[i] <= r)`   
>	}   
>	else {   
>		if(max2 < A[0]) {   
>			max2 = A[0];   
>		}   
>		b2 = 1;   
`m(A, B, C) ⋀ (l = L) ⋀ (r = R) ⋀ (Πi: i=i: (m[i] >= l) ⋀ (m[i] <= r)`   
>	}   
>	if (A[1] >= l and A[1] <= r) {   
>		sum += A[1];   
>		mult *= A[1];   
>		if (max1 < A[1]) {   
>			max1 = A[1];   
>		}   
>		b1 = 1;   
>	}   
`m(A, B, C) ⋀ (l = L) ⋀ (r = R) ⋀ (Σi: i=i: (m[i] >= l) ⋀ (m[i] <= r)`   
>	else {   
>		if (max2 < A[1]) {   
>			max2 = A[1];   
>		}   
>		b2 = 1;   
`m(A, B, C) ⋀ (l = L) ⋀ (r = R) ⋀ (Πi: i=i: (m[i] >= l) ⋀ (m[i] <= r)`   
>	}   
>	if (A[2] >= l and A[2] <= r) {   
>		sum += A[2];   
>		mult *= A[2];   
>		if (max1 < A[2]) {   
>			max1 = A[2];   
>		}   
>		b1 = 1;   
`m(A, B, C) ⋀ (l = L) ⋀ (r = R) ⋀ (Σi: i=i: (m[i] >= l) ⋀ (m[i] <= r)`   
>	}   
>	else {   
>		if (max2 < A[2]) {   
>			max2 = A[2];   
>		}   
>		b2 = 1;   
`m(A, B, C) ⋀ (l = L) ⋀ (r = R) ⋀ (Πi: i=i: (m[i] >= l) ⋀ (m[i] <= r)`   
>	}     
`m(A, B, C) ⋀ (l = L) ⋀ (r = R) ⋀ (Σi: 0<=i<3: (m[i] >= l) ⋀ (m[i] <= r) ⋀ (Πi: 0<=i<3: (m[i] >= l) ⋀ (m[i] <= r)`   
Обозначим предикат `S = (Σi: 0<=i<3: (m[i] >= l) ⋀ (m[i] <= r)`, предикат `M = (Πi: 0<=i<3: (m[i] >= l) ⋀ (m[i] <= r)`   
и `P1 = { (∀i: 0<=i<3: (m[i] > m[i-1]) ⋀ (m[i] >= l) ⋀ (m[i] <= r)):= max = m[i] }`, который равен максимуму 1;   
`P2 = { (∀i: 0<=i<3: (m[i] > m[i-1]) ⋀ (m[i] < l) ⋀ (m[i] > r)):= max = m[i] }`, который равен максимуму 2;   
>	if(b1) {   
>		if(sum > mult) {   
>		if (b1) std::cout << max1 << "\n";   
`m(A, B, C) ⋀ (l = L) ⋀ (r = R) ⋀ (S > M) ⋀ (P1)`   
>			else std::cout << "Выход за массив\n";   
`m(A, B, C) ⋀ (l = L) ⋀ (r = R) ⋀ (S < M) ⋀ (P2)`   
>		}   
>		else {   
>			if(b2) std::cout << max2 << "\n";
`m(A, B, C) ⋀ (l = L) ⋀ (r = R) ⋀ (S < M) ⋀ (P2)`   
>			else std::cout << "Выход за массив\n";   
`m(A, B, C) ⋀ (l = L) ⋀ (r = R) ⋀ (S < M) ⋀ (P1)`   
>		}   
>	}   
>	else {   
>		 std::cout << "Выход за массив\n";   
>	}   
`((S > M) ⋀ (P1)) ∨ ((S < M) ⋀ (P2))`   
 3. Составим **постлусловие** для варианта задания:   
 `((S > M) ⋀ (P1)) ∨ ((S < M) ⋀ (P2))`   
 
